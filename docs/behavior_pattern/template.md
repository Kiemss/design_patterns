# 模板方法设计模式

## 核心概念

### 模式定义
模板方法是一种行为设计模式，它在基类中定义算法的骨架，将某些步骤延迟到子类中实现。该模式允许子类在不改变算法结构的情况下重新定义算法的特定步骤。

### 核心思想
- 在基类中定义算法骨架（固定的步骤顺序），把可变步骤延迟到派生类实现
- 工厂方法是模板方法的特例：骨架只有一个抽象步骤（创建对象），由子类实现
- 封装不变部分，扩展可变部分，控制执行流程

## 模式结构

### 主要组件与标准实现
```cpp
class AbstractClass 
{
public:
    // 模板方法 - 定义算法骨架，通常声明为final
    void templateMethod() final 
    {
        primitiveOperation1();
        primitiveOperation2();
        concreteOperation();
        hook(); // 可选步骤
    }
    
    virtual ~AbstractClass() = default;

protected:
    // 抽象方法 - 必须由子类实现
    virtual void primitiveOperation1() = 0;
    virtual void primitiveOperation2() = 0;
    
    // 具体方法 - 基类提供默认实现
    void concreteOperation() 
    {
        // 默认实现
    }
    
    // 钩子方法 - 可选重写，提供默认空实现
    virtual void hook() { }
};
```

## 实现要点

### 方法分类与设计规范
- **抽象方法**必须由子类实现，使用纯虚函数声明
- **具体方法**在基类中提供完整实现，子类不应重写
- **钩子方法**提供默认空实现，子类按需选择性重写
- 模板方法通常声明为final，防止子类改变算法骨架顺序
- 公共步骤需要做好异常安全处理，避免子类异常破坏整体流程

### 命名与文档规范
- 模板方法命名为`process()`、`run()`或`load()`等动词，明确表示执行完整流程
- 在基类注释中明确说明每个步骤的职责和调用顺序
- 文档需要清晰标识哪些步骤必须实现、哪些可以重写、哪些不可修改

## 设计原则与优势

### 遵循的设计原则
- **好莱坞原则**：基类控制调用流程，子类被动实现具体步骤
- **开闭原则**：对扩展开放，支持新的子类实现；对修改关闭，保护算法骨架
- **单一职责原则**：每个子类只负责特定步骤的实现

### 优势与局限
**优势**：
- 提高代码复用性，消除重复的算法骨架代码
- 实现反向控制，基类主导执行流程
- 增强扩展性，易于添加新的具体实现
- 集中维护点，算法修改主要在基类中进行

**局限**：
- 可能违反里氏替换原则，如果子类改变算法语义
- 继承关系带来较强的耦合性
- 可能因过度细分而产生大量子类

## 与工厂方法的关系

工厂方法是模板方法在对象创建场景下的特例应用，专注于单一创建步骤的延迟实现。

## 应用场景

### 适用情况
- 多个类共享相同算法流程，但某些具体步骤实现不同
- 需要严格控制算法执行顺序，防止子类破坏流程
- 存在重复的算法骨架代码，需要提取公共基类

### 实际应用领域
1. **框架设计**：定义标准化的程序执行流程
2. **游戏开发**：敌人AI行为树、UI组件渲染流程
3. **数据处理**：ETL（提取-转换-加载）标准化流程
4. **测试框架**：测试用例的标准化执行流程

## 最佳实践

### 设计指导
- 遵循最少知识原则，保持模板方法简洁，只包含必要步骤
- 精确识别变化点，仅将真正变化的部分声明为抽象方法
- 合理使用钩子方法，为子类提供灵活的扩展点
- 在C++中使用final关键字保护模板方法不被意外重写

### 实现注意事项
- 模板方法应声明为final或非虚方法，确保算法骨架不被子类篡改
- 抽象步骤需要明确定义职责，子类实现时使用override关键字
- 为可选扩展提供钩子方法，并给出有意义的默认实现
- 在资源密集的操作中实施RAII等异常安全机制
- 通过清晰的命名表达算法的业务意图和使用场景