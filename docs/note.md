## 易错点与实践要点（面向对象 & C++）

### 1. 多态与虚析构
- 只要类可能通过基类指针或引用删除派生对象，基类必须声明 `virtual ~Base() = default;`，否则派生类析构不会被调用，可能导致资源泄漏或未定义行为。
- 有虚函数的类通常也是多态类型，显式写虚析构可表意并保证安全。

### 2. 函数签名与覆盖
- 覆盖虚函数时，参数列表和返回值（或协变返回）必须匹配父类；推荐使用 `override` 关键字以让编译器检查。
- 子类同名成员会隐藏父类成员（包括函数与变量），使用 `Base::member` 明确访问父类。

### 3. 类型转换
- static_cast：编译期转换，无运行时检查（向下转型不安全）。
- dynamic_cast：运行时类型检查，需要多态基类；指针形式失败返回 `nullptr`，引用形式抛 `std::bad_cast`。
- 设计上尽量避免下转（dynamic_cast），把必要行为抽象进基类或使用模式（Visitor/策略）。

### 4. 所有权与智能指针
- 对通过智能指针删除多态对象，基类必须有虚析构。

### 5. 返回值风格
- 返回 `unique_ptr<T>` 表达“移交所有权”；返回按值适用于小或可高效移动的对象。
- 对于局部unique_ptr，可以直接return，底层会自动move

### 6. 代码风格与检查点
- 使用 `override`、`final` 和 `= default`/`= delete` 明确意图。
- Checklist:
  - 基类有虚函数时是否有虚析构？
  - Factory/Builder 是否显式表达所有权语义？
  - 是否避免不安全的 static_cast 下转？