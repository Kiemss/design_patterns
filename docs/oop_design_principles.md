# 面向对象与设计模式基础

## 类三大特性

### 封装
* **定义**：将数据和操作数据的方法捆绑在一起，隐藏内部实现细节
* **目的**：提高安全性，简化使用，降低耦合度
* **实现方式**：通过访问修饰符控制成员的可见性

### 继承
* **定义**：子类可以复用父类的属性和方法
* **类型**：
  * 单继承：一个子类只能有一个父类
  * 多继承：一个子类可以有多个父类（某些语言支持）
* **优点**：代码复用，扩展性强

### 多态
* **定义**：同一接口可以有多种不同的实现方式
* **类型**：
  * 编译时多态：方法重载
  * 运行时多态：方法重写
* **实现基础**：继承 + 方法重写 + 父类引用指向子类对象

## UML类图表示法

### 访问修饰符
```
+ public    # 公有成员，任何类都可访问
# protected # 保护成员，仅子类和自身可访问  
- private   # 私有成员，仅自身可访问
~ package   # 包内可见（Java）
```

### 成员表示
```
variable : element_type          # 变量名:类型
func (variable : element_type) : return_type  # 方法名(参数:类型):返回类型
static_member : type             # 静态成员：下划线
abstract_method()                # 抽象方法：斜体
```

### 完整示例
```UML
ClassName
---------
- private_var : int
# protected_var : String
+ public_var : double
_ static_var : boolean
---------
+ Constructor(param : int)
+ public_method() : void
# protected_method() : String
- private_method() : int
_ static_method() : void
```

## 类间关系详解

### 继承关系（泛化）
* **表示**：空心三角形箭头，子类指向父类
* **特点**：is-a关系，强耦合
* **UML**：`子类 ─────▷ 父类`

### 实现关系
* **表示**：空心三角形箭头 + 虚线
* **特点**：类实现接口
* **UML**：`实现类 ╌╌╌╌╌◁ 接口`

### 关联关系
* **单向关联**：
  * **表示**：实线箭头指向被包含的类
  * **示例**：`Student ─────▶ Address`
  * **代码**：`class Student { private Address address; }`

* **双向关联**：
  * **表示**：实线箭头互相指向
  * **示例**：`Teacher ◀─────▶ Student`
  * **代码**：互相持有引用

* **自关联**：
  * **表示**：实线箭头指向自己
  * **示例**：`Node ─────▶ Node`
  * **代码**：`class Node { private Node next; }`

### 聚合关系
* **表示**：空心菱形箭头指向整体类
* **特点**：has-a关系，整体与部分可独立存在
* **生命周期**：整体类被销毁时，部分仍然存在
* **UML**：`部分类 ◇───── 整体类`
* **示例**：`计算机 ◇───── CPU`，计算机销毁后CPU仍可用

### 组合关系
* **表示**：实心菱形箭头指向整体类
* **特点**：contains-a关系，部分不能独立存在
* **生命周期**：整体类被销毁时，部分随之销毁
* **UML**：`部分类 ◆───── 整体类`
* **示例**：`窗口 ◆───── 按钮`，窗口关闭按钮随之销毁

### 依赖关系
* **表示**：带箭头的虚线，由依赖方指向被依赖方
* **特点**：use-a关系，最弱的关系，临时性使用
* **UML**：`依赖类 ╌╌╌╌╌▶ 被依赖类`
* **触发条件**：
  * 方法参数：`void method(OtherClass obj)`
  * 局部变量：`void method() { OtherClass obj = new OtherClass(); }`
  * 静态方法调用：`OtherClass.staticMethod()`

### 关系强度排序
**继承 > 组合 > 聚合 > 关联 > 依赖**

| 关系类型 | 强度 | 耦合度 | 生命周期关联 |
| -------- | ---- | ------ | ------------ |
| 继承     | 最强 | 高     | 无直接关联   |
| 组合     | 强   | 高     | 同步         |
| 聚合     | 中等 | 中     | 独立         |
| 关联     | 弱   | 中     | 独立         |
| 依赖     | 最弱 | 低     | 无关联       |

## 设计模式基本原则

### 单一职责原则 (SRP)
* **核心思想**：一个类只负责一个功能领域中的相应职责
* **定义**：就一个类而言，应该仅有一个引起它变化的原因
* **好处**：
  * 提高类的内聚性
  * 降低类的复杂度
  * 提高可维护性
  * 降低变更风险
* **违反示例**：
  ```java
  // 违反SRP：一个类承担了用户信息管理和用户显示两个职责
  class User {
      void saveToDatabase() { ... }
      void displayOnScreen() { ... }
  }
  ```

### 开放封闭原则 (OCP)
* **核心思想**：对扩展开放，对修改封闭
* **定义**：软件实体应该可以扩展，但不可修改
* **实现方式**：
  * 使用抽象和接口
  * 通过多态实现功能扩展
  * 使用策略模式、模板方法模式等
* **示例**：
  ```java
  // 通过接口实现OCP
  interface Shape {
      double calculateArea();
  }
  
  class Circle implements Shape { ... }
  class Rectangle implements Shape { ... }
  ```

### 依赖倒置原则 (DIP)
* **核心思想**：
  * 高层模块不应依赖底层模块，两者都应依赖抽象
  * 抽象不应依赖细节，细节应依赖抽象
* **实现方式**：
  1. 定义包含抽象方法的接口或抽象类
  2. 高层模块通过抽象接口调用功能
  3. 不同实现通过继承/实现抽象接口提供具体功能
  4. 使用依赖注入容器管理依赖关系
* **示例**：
  ```java
  // 抽象接口
  interface MessageSender {
      void send(String message);
  }
  
  // 高层模块依赖抽象
  class NotificationService {
      private MessageSender sender;
      
      public NotificationService(MessageSender sender) {
          this.sender = sender; // 依赖注入
      }
  }
  ```

### 里氏代换原则 (LSP)
* **核心思想**：子类类型必须能够替换它们的父类类型
* **定义**：所有引用基类的地方必须能透明地使用其子类的对象
* **具体要求**：
  * 子类必须完全实现父类的方法
  * 子类可以有自己的个性
  * 覆盖或实现父类的方法时，输入参数可以被放大
  * 覆盖或实现父类的方法时，输出结果可以被缩小
* **违反示例**：
  ```java
  class Rectangle {
      protected int width, height;
      
      void setWidth(int w) { width = w; }
      void setHeight(int h) { height = h; }
  }
  
  class Square extends Rectangle {
      // 违反LSP：改变了父类的行为契约
      void setWidth(int w) { width = height = w; }
      void setHeight(int h) { width = height = h; }
  }
  ```

### 接口隔离原则 (ISP)
* **核心思想**：客户端不应该依赖它不需要的接口
* **定义**：使用多个专门的接口比使用单一的总接口要好
* **好处**：
  * 降低接口复杂度
  * 提高系统灵活性
  * 减少不必要的依赖
* **示例**：
  ```java
  // 违反ISP：一个接口包含太多方法
  interface Worker {
      void work();
      void eat();
      void sleep();
  }
  
  // 遵循ISP：拆分为多个专门接口
  interface Workable { void work(); }
  interface Eatable { void eat(); }
  ```

### 迪米特法则 (LoD)
* **核心思想**：一个对象应该对其他对象有最少的了解
* **定义**：只与直接的朋友通信
* **朋友定义**：
  * 当前对象本身
  * 以参数形式传入到当前对象方法中的对象
  * 当前对象的成员对象
  * 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
* **好处**：降低耦合度，提高模块独立性

## 设计原则总结

| 原则名称   | 英文 | 核心思想               | 关键点         |
| ---------- | ---- | ---------------------- | -------------- |
| 单一职责   | SRP  | 一个类只做一件事       | 高内聚，低耦合 |
| 开放封闭   | OCP  | 对扩展开放，对修改关闭 | 抽象，多态     |
| 里氏代换   | LSP  | 子类可替换父类         | 继承规范       |
| 接口隔离   | ISP  | 接口要小而专           | 接口精简       |
| 依赖倒置   | DIP  | 面向接口编程           | 依赖抽象       |
| 迪米特法则 | LoD  | 最少知识原则           | 降低耦合       |

这些设计原则共同构成了面向对象设计的基石，指导我们编写出可维护、可扩展、可复用的高质量代码。在实际开发中，应该综合考虑这些原则，根据具体场景灵活应用。
