# 原型模式（Prototype Pattern）

## 核心概念

- **定义**：对象自身提供 `clone()` 接口，用于返回一个与当前状态一致的新实例，避免重复构造成本。
- **自我复制**：对象通过克隆函数创建自身的副本，不依赖外部类
- **适用场景**：构造/初始化非常昂贵、需要在运行时动态生成不同实例、希望将创建逻辑与具体类解耦。
- **与工厂模式区别**：工厂关注"根据参数创建新对象"；原型关注"基于现有样本快速复制"，无需重新传参或了解构造细节。

## 设计要点

### 接口设计
```cpp
class Prototype 
{
public:
    virtual std::unique_ptr<Prototype> clone() const = 0;
    virtual ~Prototype() = default;
};
```

### 具体实现要求
- ConcretePrototype 通过拷贝构造或自定义深拷贝逻辑实现 `clone()`
- clone 必须返回所有权（推荐 `std::unique_ptr`），并保证深拷贝语义
- 拥有指针资源时，在 clone 中新建副本
- 使用智能指针避免裸指针泄漏

### 深拷贝保证
- **深拷贝必须**：确保复制出的对象完全独立，共享数据需要深度复制
- **指针成员**：必须创建新内存并复制数据
- **容器成员**：需要遍历复制每个元素  
- **对象成员**：递归调用其克隆方法或拷贝构造

## 实践规范

### 原型对象管理
- 原型对象应视为**模板**：注册在 registry 中，仅供克隆
- 原型对象不直接参与业务逻辑，以防被意外修改
- 保持原型对象的初始状态一致性
- 避免对原型对象进行业务操作，防止污染克隆结果

### 内存安全
- 基类必须声明虚析构函数，确保通过基类指针删除时派生析构被调用
- 使用 `std::unique_ptr` 管理资源所有权
- 避免原始指针和智能指针混用

### 架构模式
- **registry 模式**：使用 `std::unordered_map<std::string, std::unique_ptr<Prototype>>` 存储模板
- `create(id)` 时调用 `clone()` 创建新实例
- 克隆后允许在新对象上调用 setter 或 Builder 做微调，但模板本身应保持只读

### 并发安全
- 若 registry 在多线程间共享，需要加锁或使用线程安全容器
- 原型对象本身应该是无状态的或只读的

## 应用场景

### 适合使用原型模式
- **游戏开发**：敌人、道具、角色的快速复制
- **文档模板**：基于模板创建新文档
- **配置对象**：默认配置的克隆和微调
- **性能优化**：避免重复的昂贵初始化过程

## 现代C++实现技巧

### 智能指针管理
```cpp
std::unique_ptr<Product> clone() const 
{
    std::unique_ptr<int> new_data;
    if (m_data) 
    {
        new_data = std::make_unique<int>(*m_data); // 深拷贝数据
    }
    return std::make_unique<Product>(m_ID, std::move(new_data));
}
```

### 多态克隆支持
```cpp
class Cloneable 
{
public:
    virtual ~Cloneable() = default;
    virtual std::unique_ptr<Cloneable> clone() const = 0;
};
```

## 优缺点分析

### 优点
- **创建效率**：避免重复的初始化过程
- **灵活性**：运行时动态创建对象变体
- **简化结构**：减少子类数量和工厂类依赖

### 缺点
- **深拷贝复杂性**：复杂对象的克隆实现较复杂
- **循环引用风险**：对象间引用可能导致问题
- **原型管理**：需要维护原型对象的纯净性

## 实现检查要点

- `clone()` 方法应标记为 `const` 并返回 `std::unique_ptr`
- 所有拥有的资源必须实现深拷贝或明确所有权转移
- 基类必须声明虚析构函数以确保正确的多态删除
- 原型模板对象应严格只用于克隆操作，避免直接修改
- registry 与 clone 流程应有清晰的文档说明

## 实践建议

1. **明确使用场景**：仅在需要快速复制现有对象时使用
2. **保证深拷贝**：仔细处理所有指针和引用成员
3. **原型隔离**：将原型对象与业务对象分开管理
4. **性能考量**：在对象创建成本高时优势明显